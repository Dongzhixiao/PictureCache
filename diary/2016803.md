### 时间:2016年8月3日 天气:雷阵雨转多云:umbrella:->:cloud:
-----
#####   Author:冬之晓:dizzy_face:
#####   Email: 347916416@qq.com
#####   MyAppearance: ![MyAppearance](../MyPicture.JPG "我的头像")
----------

<pre>
    今天,开始继续进行上周五收到的任务，发现了程序里面有好多不同的编码风格，让
我在编程的时候比较费劲，必须读好几个不同的人写的程序，而且同一个实现每个人用
的方法都不一样，有些还是错的，今天我终于明白接手一个半截程序的痛苦了……
</pre>

---------

#### 条款03：确定对象被使用前以先被初始化

- 为内置型对象进行手工初始化，因为C\+\+不保证初始化它们。
>对于内置类型以外的其它类型，初始化责任落在构造函数，确保每一个构造函数都将对象的每一个成员初始化。C\+\+中的内置基本类型，比如int，double，float等，初值都是垃圾值，即声明`int i`，i的初值是一个垃圾值。本书建议的最佳处理方法是：永远在使用对象之前将之初始化。
- STL
>C++提供了丰富的容器，比如vector，list，deque，map和set等，这些容器已经写好了构造函数，所以总会自动初始化成默认值，程序员可以直接使用，比如：

`vector<int> vt; vt.push_back(3);`

- 自定义类
>C++在类中有专门初始化成员变量的构造函数，程序员可以写出合适的构造函数，比如：

```C++
class A
{
private:
    int a;
    double b;
    string text;
  
public:
    A():a(0), b(0), text("hello world"){} //构造函数
};
```

>当声明  
`A obj;`  
时，obj的成员变量a，b和text就已经获得了初值，分别是0，0和hello world。
这里注意一下，有些C++的初学者喜欢这样写：

```C++
class A

{
private:
    int a;
    double b;
    string text;

public:
    A()
    {
        a = 0;
        b = 0;
        text = "hello world";
    }
};
```

>效果虽然和上一个例子一样，都获得了指定的初值，但执行的效率却不如上个例子。上一个例子中使用了成员初始化列表的方式，即在冒号后面逐一初始化，但本例却在函数体内进行了初始化。事实上，本例其实不能严格称为“初始化”，因为在进入构造函数的函数体时，这些成员变量已经被初始化了，**a和b初始化成垃圾值**，string因为属于STL，调用**默认的构造函数**初始化为空字符串，在函数体内进行的操作实为“赋值”，也就是用新值覆盖旧值。这也正是说它的执行效率不高的原因:**既进行了初始化，又在之后进行了赋值**!不像上一个例子，只有初始化，一步到位。在有些特殊情况下，比如**成员变量是const的或者是reference的，进行初始化后值就不可以改变了**，这时**只能用初始化列表，不能在函数体内赋值。**不过最新的C++11版本出来后，class允许非静态（non-static）数据成员在其声明处（在其所属类内部）进行初始化，相当于初始化列表，真的是非常好！

>所以，应该尽可能地采用有冒号的成员初始化列表。注意这里的用词“尽可能地”，表示也不是所有情况都用这个初始化列表，**当构造的内容复杂，或者已经模块化为函数了，这时不能用初始化列表的方式，就采用在函数体内赋值的方式为好。**

>这里还有一个问题要注意下，当使用初始化列表时，初始成员变量的顺序与列表排列的顺序没有关系，只取决于声明这些成员变量的顺序

- 不同编译单元内定义的non-local static 对象
>这里先解释一下名词，static是静态的意思，表示这个变量不由栈分配，而存储在特有的全局变量/静态变量区域中，具有长寿命的特点（从被构造出来，直到程序结束时，才会由系统释放资源）；而non-local则是说这个对象是全局的，而不是函数内的静态变量，是说它的作用范围广。

比如在文件1中定义了

`int a = 1;`

而在文件2中又会去使用：

`extern int a;`
`int b = a *3;`

可以看到文件1应在文件2之后执行，这样a才能获得初值，否则b得到的将是垃圾值，但事实上C++对于不同文件执行的相对次序并无明确定义，这样b究竟得到的是垃圾值还是3就不能确定。

解决这个问题是方法是不要使变量有全局的作用域，可以在文件1中定义：

```C++
int& GetA()
{
    static int a = 1;          
    return a;
}
```

而在文件2中调用

`int b = GetA();`

这样就一定保证a的初始化在先了。


#### 请记住：

- [x] ***为内置型对象进行手工初始化，因为C++不保证初始化它们***
- [x] ***构造函数最好使用成员初始化列表（实际初始化顺序不与列表的排列顺序有关，只取决于类中的声明顺序），而不要在构造函数体内使用赋值操作***
- [x] ***未避免“跨编译单元的初始化次序”问题，请用local static代替non-local static对象***

